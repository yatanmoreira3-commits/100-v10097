#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ARQV30 Enhanced v2.0 - Component Orchestrator
Orquestrador seguro de componentes com valida√ß√£o rigorosa
"""

import logging
import time
import json
from typing import Dict, List, Any, Optional, Callable
from datetime import datetime

logger = logging.getLogger(__name__)

class ComponentValidationError(Exception):
    """Exce√ß√£o para erros de valida√ß√£o de componentes"""
    pass

class ComponentOrchestrator:
    """Orquestrador seguro de componentes da an√°lise"""
    
    def __init__(self):
        """Inicializa o orquestrador"""
        self.component_registry = {}
        self.execution_order = []
        self.validation_rules = {}
        self.component_results = {}
        self.execution_stats = {}
        
        logger.info("Component Orchestrator inicializado")
    
    def register_component(
        self, 
        name: str, 
        executor: Callable,
        dependencies: List[str] = None,
        validation_rules: Dict[str, Any] = None,
        required: bool = True
    ):
        """Registra um componente no orquestrador"""
        
        self.component_registry[name] = {
            'executor': executor,
            'dependencies': dependencies or [],
            'validation_rules': validation_rules or {},
            'required': required,
            'status': 'pending'
        }
        
        if name not in self.execution_order:
            self.execution_order.append(name)
        
        logger.info(f"üìù Componente registrado: {name}")
    
    def execute_components(
        self, 
        input_data: Dict[str, Any],
        progress_callback: Optional[Callable] = None
    ) -> Dict[str, Any]:
        """Executa todos os componentes registrados em ordem"""
        
        logger.info(f"üöÄ Iniciando execu√ß√£o de {len(self.component_registry)} componentes")
        start_time = time.time()
        
        successful_components = {}
        failed_components = {}
        
        for i, component_name in enumerate(self.execution_order):
            if progress_callback:
                progress_callback(i + 1, f"Executando {component_name}...")
            
            try:
                # Verifica depend√™ncias
                if not self._check_dependencies(component_name):
                    error_msg = f"Depend√™ncias n√£o atendidas para {component_name}"
                    logger.error(f"‚ùå {error_msg}")
                    failed_components[component_name] = error_msg
                    self._mark_component_failed(component_name, error_msg)
                    continue
                
                # Executa componente
                result = self._execute_single_component(component_name, input_data, successful_components)
                
                # Verifica se houve erro no resultado
                if result is not None and not isinstance(result, dict) or not result.get('error'):
                    # Valida resultado
                    if self._validate_component_result(component_name, result):
                        successful_components[component_name] = result
                        self._mark_component_successful(component_name, result)
                        logger.info(f"‚úÖ Componente {component_name} executado com sucesso")
                    else:
                        error_msg = f"Resultado inv√°lido para {component_name}"
                        logger.error(f"‚ùå {error_msg}")
                        failed_components[component_name] = error_msg
                        self._mark_component_failed(component_name, error_msg)
                elif result and isinstance(result, dict) and result.get('error'):
                    # Componente retornou com erro expl√≠cito
                    error_msg = f"Componente {component_name} falhou: {result.get('error')}"
                    logger.error(f"‚ùå {error_msg}")
                    failed_components[component_name] = error_msg
                    self._mark_component_failed(component_name, error_msg)
                else:
                    error_msg = f"Componente {component_name} retornou None ou resultado inv√°lido"
                    logger.error(f"‚ùå {error_msg}")
                    failed_components[component_name] = error_msg
                    self._mark_component_failed(component_name, error_msg)
                
            except Exception as e:
                error_msg = f"Erro na execu√ß√£o de {component_name}: {str(e)}"
                logger.error(f"‚ùå {error_msg}")
                failed_components[component_name] = error_msg
                self._mark_component_failed(component_name, error_msg)
                
                # Se √© componente obrigat√≥rio, pode interromper
                if self.component_registry[component_name]['required']:
                    logger.error(f"üö® Componente obrigat√≥rio {component_name} falhou - an√°lise comprometida")
        
        execution_time = time.time() - start_time
        
        # Gera relat√≥rio final
        execution_report = {
            'successful_components': successful_components,
            'failed_components': failed_components,
            'execution_stats': {
                'total_components': len(self.component_registry),
                'successful_count': len(successful_components),
                'failed_count': len(failed_components),
                'success_rate': (len(successful_components) / len(self.component_registry)) * 100,
                'execution_time': execution_time,
                'timestamp': datetime.now().isoformat()
            },
            'component_details': self.execution_stats
        }
        
        logger.info(f"üìä Execu√ß√£o conclu√≠da: {len(successful_components)}/{len(self.component_registry)} componentes bem-sucedidos")
        
        return execution_report
    
    def _check_dependencies(self, component_name: str) -> bool:
        """Verifica se as depend√™ncias de um componente foram atendidas"""
        
        component = self.component_registry.get(component_name, {})
        dependencies = component.get('dependencies', [])
        
        for dependency in dependencies:
            if dependency not in self.component_results or self.component_results[dependency]['status'] != 'success':
                logger.warning(f"‚ö†Ô∏è Depend√™ncia {dependency} n√£o atendida para {component_name}")
                return False
        
        return True
    
    def _execute_single_component(
        self, 
        component_name: str, 
        input_data: Dict[str, Any],
        previous_results: Dict[str, Any]
    ) -> Any:
        """Executa um √∫nico componente"""
        
        component = self.component_registry[component_name]
        executor = component['executor']
        
        start_time = time.time()
        
        try:
            # Prepara dados de entrada incluindo resultados anteriores
            execution_data = {
                **input_data,
                'previous_results': previous_results
            }
            
            # Executa o componente
            result = executor(execution_data)
            
            execution_time = time.time() - start_time
            
            # Registra estat√≠sticas
            self.execution_stats[component_name] = {
                'execution_time': execution_time,
                'status': 'success',
                'result_size': len(str(result)) if result else 0
            }
            
            return result
            
        except Exception as e:
            execution_time = time.time() - start_time
            
            self.execution_stats[component_name] = {
                'execution_time': execution_time,
                'status': 'failed',
                'error': str(e)
            }
            
            raise e
    
    def _validate_component_result(self, component_name: str, result: Any) -> bool:
        """Valida o resultado de um componente"""
        
        component = self.component_registry.get(component_name, {})
        validation_rules = component.get('validation_rules', {})
        
        if not validation_rules:
            # Se n√£o h√° regras espec√≠ficas, valida se n√£o √© None/vazio
            return result is not None
        
        try:
            # Valida tipo
            expected_type = validation_rules.get('type')
            if expected_type and not isinstance(result, expected_type):
                logger.error(f"‚ùå Tipo inv√°lido para {component_name}: esperado {expected_type}, recebido {type(result)}")
                return False
            
            # Valida campos obrigat√≥rios
            required_fields = validation_rules.get('required_fields', [])
            if isinstance(result, dict):
                for field in required_fields:
                    if field not in result or not result[field]:
                        logger.error(f"‚ùå Campo obrigat√≥rio ausente em {component_name}: {field}")
                        return False
            
            # Valida tamanho m√≠nimo
            min_size = validation_rules.get('min_size')
            if min_size:
                if isinstance(result, (list, dict, str)):
                    if len(result) < min_size:
                        logger.error(f"‚ùå Tamanho insuficiente para {component_name}: {len(result)} < {min_size}")
                        return False
            
            # Valida se h√° erros expl√≠citos no resultado
            if isinstance(result, dict) and result.get('error'):
                logger.error(f"‚ùå Erro detectado no resultado de {component_name}: {result.get('error')}")
                return False
            
            # Valida se conte√∫do n√£o √© fallback/gen√©rico
            if isinstance(result, dict):
                result_str = json.dumps(result, ensure_ascii=False).lower()
                
                # Indicadores de conte√∫do falso/gen√©rico
                fallback_indicators = [
                    'em desenvolvimento', 'fallback', 'n√£o dispon√≠vel', 'erro na',
                    'driver 1', 'driver 2', 'customizado para', 'baseado em',
                    'espec√≠fico para', 'dados n√£o dispon√≠veis', 'an√°lise em desenvolvimento'
                ]
                
                found_fallback = [indicator for indicator in fallback_indicators if indicator in result_str]
                
                if found_fallback:
                    logger.error(f"‚ùå Conte√∫do gen√©rico/fallback detectado em {component_name}: {found_fallback}")
                    return False
                
                # Verifica se tem estrutura m√≠nima de dados reais
                if component_name == 'mental_drivers':
                    drivers = result.get('drivers', [])
                    if not drivers or len(drivers) < 19:
                        logger.error(f"‚ùå {component_name}: drivers insuficientes ({len(drivers) if drivers else 0}/19)")
                        return False
                    
                    # Verifica se drivers t√™m conte√∫do real
                    generic_drivers = sum(1 for d in drivers if 'em desenvolvimento' in str(d).lower())
                    if generic_drivers > 5:  # M√°ximo 5 drivers gen√©ricos permitidos
                        logger.error(f"‚ùå {component_name}: muitos drivers gen√©ricos ({generic_drivers}/19)")
                        return False
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro na valida√ß√£o de {component_name}: {str(e)}")
            return False
    
    def _mark_component_successful(self, component_name: str, result: Any):
        """Marca componente como bem-sucedido"""
        self.component_results[component_name] = {
            'status': 'success',
            'result': result,
            'timestamp': time.time()
        }
        
        self.component_registry[component_name]['status'] = 'success'
    
    def _mark_component_failed(self, component_name: str, error: str):
        """Marca componente como falho"""
        self.component_results[component_name] = {
            'status': 'failed',
            'error': error,
            'timestamp': time.time()
        }
        
        self.component_registry[component_name]['status'] = 'failed'
    
    def get_execution_summary(self) -> Dict[str, Any]:
        """Retorna resumo da execu√ß√£o"""
        
        successful = [name for name, result in self.component_results.items() if result['status'] == 'success']
        failed = [name for name, result in self.component_results.items() if result['status'] == 'failed']
        
        return {
            'total_components': len(self.component_registry),
            'successful_components': successful,
            'failed_components': failed,
            'success_rate': (len(successful) / len(self.component_registry)) * 100 if self.component_registry else 0,
            'execution_stats': self.execution_stats,
            'component_results': {name: result['result'] for name, result in self.component_results.items() if result['status'] == 'success'}
        }
    
    def reset(self):
        """Reseta o estado do orquestrador"""
        self.component_results = {}
        self.execution_stats = {}
        
        for component in self.component_registry.values():
            component['status'] = 'pending'
        
        logger.info("üîÑ Orquestrador resetado")

# Inst√¢ncia global
component_orchestrator = ComponentOrchestrator()